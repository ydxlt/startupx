package io.geek.lib.startup.compiler;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;

import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.util.Elements;


public class TaskCollectorHelper {

    private static final String COLLECTOR_NAME = "TaskCollector_Impl"; // %s进程名字

    private TypeElement typeElement;
    private Elements elements;
    private Map<String,List<ClassName>> classNameMap;
    private List<ClassName> defaultTaskList;
    private int mProcessNum;

    public TaskCollectorHelper(Elements elements, Map<String,List<ClassName>> classNameMap,
                               List<ClassName> defaultTaskList) {
        this.typeElement = elements.getTypeElement(ClassNames.TASK_COLLECTOR.canonicalName());
        this.elements = elements;
        this.classNameMap = classNameMap;
        this.defaultTaskList = defaultTaskList;
    }

    public JavaFile brewJava() {
        String packageName = elements.getPackageOf(typeElement).getQualifiedName().toString();
        return JavaFile.builder(packageName, TypeSpec.classBuilder(
                COLLECTOR_NAME
        ).addJavadoc("Generated by compiler,Please do not edit it!")
                .addSuperinterface(ClassNames.TASK_COLLECTOR)
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addMethod(collectSpec())
                .build())
                .build();
    }

    private MethodSpec collectSpec() {
        CodeBlock.Builder statementBuilder = CodeBlock.builder()
                .addStatement("$T tasks = new $T()", ParameterizedTypeName.get(ClassNames.LIST, ClassNames.TASK),
                        ParameterizedTypeName.get(ClassNames.ARRAY_LIST, ClassNames.TASK));
        classNameMap.forEach((process, classNameList) -> {
            if(!classNameList.isEmpty()) {
                if(mProcessNum > 0) {
                    statementBuilder.beginControlFlow("else if($T.equals(process,$S))", ClassNames.TEXT_UTILS, process);
                } else {
                    statementBuilder.beginControlFlow("if($T.equals(process,$S))", ClassNames.TEXT_UTILS, process);
                }
                for(ClassName className : classNameList){
                    statementBuilder.addStatement("tasks.add(new $T())", className);
                }
                statementBuilder.endControlFlow();
                mProcessNum++;
            }
        });
        if(!defaultTaskList.isEmpty()){
            if(mProcessNum > 0) {
                statementBuilder.beginControlFlow("else");
            }
            for(ClassName className : defaultTaskList){
                statementBuilder.addStatement("tasks.add(new $T())", className);
            }
            if(mProcessNum > 0) {
                statementBuilder.endControlFlow();
            }
        }
        statementBuilder.addStatement("return tasks");
        return MethodSpec.methodBuilder("collect")
                .addParameter(ClassName.get(String.class),"process")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(ParameterizedTypeName.get(ClassNames.LIST, ClassNames.TASK))
                .addCode(statementBuilder.build())
                .build();
    }
}
