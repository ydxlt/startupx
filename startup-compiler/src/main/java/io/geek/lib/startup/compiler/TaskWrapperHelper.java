package io.geek.lib.startup.compiler;

import androidx.annotation.Nullable;

import com.squareup.javapoet.ArrayTypeName;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.WildcardTypeName;

import java.util.List;
import java.util.function.Consumer;

import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.MirroredTypesException;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;

import io.geek.lib.startup.StartupTask;

public class TaskWrapperHelper {

    private static final String TASK_WRAPPER_NAME = "%s_Wrapper";
    private TypeElement typeElement;
    private Elements elements;
    private Types types;
    private JavaFile javaFile;
    private ClassName className;
    private String[] processName;
    private List<? extends TypeMirror> mDependencies;
    private String mTaskName;

    public TaskWrapperHelper(TypeElement typeElement, Elements elements, Types types) {
        this.typeElement = typeElement;
        this.elements = elements;
        this.types = types;
        init();
    }

    private void init() {
        StartupTask startupTask = typeElement.getAnnotation(StartupTask.class);
        String packageName = elements.getPackageOf(typeElement).getQualifiedName().toString();
        String wrapperClassName = String.format(TASK_WRAPPER_NAME, typeElement.getSimpleName().toString());
        javaFile = JavaFile.builder(packageName, TypeSpec.classBuilder(
                wrapperClassName
        ).addJavadoc("Generated by compiler, please do not edit it!")
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addSuperinterface(ClassNames.TASK)
                .addField(FieldSpec.builder(ClassNames.TASK, "mTask", Modifier.PRIVATE, Modifier.FINAL)
                        .initializer("new $T()", typeElement.asType())
                        .build())
                .addMethod(threadModeSpec(startupTask))
                .addMethod(dependenciesSpec(startupTask))
                .addMethod(processSpec(startupTask))
                .addMethod(prioritySpec(startupTask))
                .addMethod(executeSpec())
                .build())
                .build();
        processName = startupTask.process();
        className = ClassName.bestGuess(String.format(TASK_WRAPPER_NAME, typeElement.getQualifiedName().toString()));
        mDependencies = getDependencies(startupTask);
        mTaskName = typeElement.getQualifiedName().toString();
    }

    public ClassName getWrapperClassName() {
        return className;
    }

    public String[] getProcessName() {
        return processName;
    }

    public List<? extends TypeMirror> getDependencies() {
        return mDependencies;
    }

    public String getTaskName() {
        return mTaskName;
    }

    public JavaFile getJavaFile() {
        return javaFile;
    }

    private MethodSpec executeSpec() {
        return MethodSpec.methodBuilder("execute")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(ClassName.get("android.app", "Application"), "context")
                .addStatement("mTask.execute(context)")
                .build();
    }

    private List<? extends TypeMirror> getDependencies(StartupTask startupTask) {
        try {
            startupTask.dependencies();
        } catch (MirroredTypesException e) {
            return e.getTypeMirrors();
        }
        return null;
    }

    private MethodSpec dependenciesSpec(StartupTask startupTask) {
        List<? extends TypeMirror> types = getDependencies(startupTask);
        types.forEach((Consumer<TypeMirror>) typeMirror -> {
            // 判断是否存在自己依赖自己
            if (typeMirror.equals(typeElement.asType())) {
                throw new CompileException("Task " + typeElement.getQualifiedName() + " cannot depend on itself!");
            }
            if(this.types.asElement(typeMirror).getKind().isInterface()){
                throw new CompileException("Task " + typeElement.getQualifiedName() +" dependencies cannot be a interface!\n error interface: "+typeMirror);
            }
        });
        ParameterizedTypeName taskClass = ParameterizedTypeName.get(ClassName.get("java.lang", "Class"),
                WildcardTypeName.subtypeOf(ClassNames.TASK));
        CodeBlock.Builder statement = CodeBlock.builder()
                .addStatement("$T<Class<? extends Task>> tasks = mTask.dependencies()", List.class)
                .beginControlFlow("if(tasks != null)")
                .addStatement("return tasks")
                .endControlFlow()
                .addStatement("tasks = new $T<>()", ClassNames.ARRAY_LIST);
        for (TypeMirror type : types) {
            statement.addStatement("tasks.add($T.class)", type);
        }
        return MethodSpec.methodBuilder("dependencies")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(ParameterizedTypeName.get(ClassNames.LIST, taskClass))
                .addCode(statement.build())
                .addStatement("return tasks")
                .build();
    }

    private String formatArray(String[] array){
        StringBuilder stringBuilder = new StringBuilder();
        int count = array.length;
        for(String str : array){
            count--;
            stringBuilder.append("\"");
            stringBuilder.append(str);
            stringBuilder.append("\"");
            if(count != 0) {
                stringBuilder.append(",");
            }
        }
        return stringBuilder.toString();
    }

    private MethodSpec processSpec(StartupTask startupTask) {
        CodeBlock statement = CodeBlock.builder()
                .addStatement("$T[] process = mTask.process()",String.class)
                .beginControlFlow("if(process != null)")
                .addStatement("return process")
                .endControlFlow()
                .addStatement("return new $T[]{$L}", String.class, formatArray(startupTask.process()))
                .build();
        return MethodSpec.methodBuilder("process")
                .addAnnotation(Nullable.class)
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(ArrayTypeName.of(ClassName.get(String.class)))
                .addCode(statement)
                .build();
    }

    private MethodSpec prioritySpec(StartupTask startupTask) {
        CodeBlock statement = CodeBlock.builder()
                .addStatement("int priority = mTask.priority()")
                .beginControlFlow("if(priority != 0)")
                .addStatement("return priority")
                .endControlFlow()
                .addStatement("return $L", startupTask.priority())
                .build();
        return MethodSpec.methodBuilder("priority")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(TypeName.INT)
                .addCode(statement)
                .build();
    }

    private MethodSpec threadModeSpec(StartupTask startupTask) {
        CodeBlock statement = CodeBlock.builder()
                .addStatement("ThreadMode threadMode = mTask.threadMode()")
                .beginControlFlow("if(threadMode != null)")
                .addStatement("return threadMode")
                .endControlFlow()
                .addStatement("return $T.$L", ClassNames.THREAD_MODE, startupTask.threadMode())
                .build();
        return MethodSpec.methodBuilder("threadMode")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(ClassNames.THREAD_MODE)
                .addCode(statement)
                .build();
    }
}
